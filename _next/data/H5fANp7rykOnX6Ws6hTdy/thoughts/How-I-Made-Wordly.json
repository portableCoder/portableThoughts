{"pageProps":{"pageContext":{"image":"https://github.com/portableCoder/Wordly/raw/main/source/react.gif","date":"01/02/2022","title":"How I Created A CLI Based Wordle Clone With React","description":"Meet wordly","md":"\r\nReact is one of the most popular front end frameworks out there. It supports a plethora of different platforms, but what you might not have known is that you\r\ncan even build a CLI application with react.\r\n\r\nThere are thousands of different wordle clones you can find online these days, mostly web-based. I wanted to recreate it too, but I had a different approach -- I wanted to make it a cli-based game. I also wanted to use react to make it, so I opted on using the great [React-Ink](https://github.com/vadimdemedes/ink) library which allows you to build react-based\r\nCLI-applications by utilizing a custom renderer for the command line.\r\n\r\nI started by initializing a 6x5 in a state like so:\r\n\r\n```ts\r\nconst [wordMatrix, setWordMatrix] = useState(() => {\r\n  let arr: Array<\r\n    Array<{\r\n      bgColor: LiteralUnion<typeof ForegroundColor, string>;\r\n      letter: string;\r\n    }>\r\n  > = [];\r\n  for (let index = 0; index < 6; index++) {\r\n    let arr_temp: Array<{\r\n      bgColor: LiteralUnion<typeof ForegroundColor, string>;\r\n      letter: string;\r\n    }> = [];\r\n    for (let j = 0; j < 5; j++) {\r\n      arr_temp.push({ bgColor: null, letter: \"\" });\r\n    }\r\n    arr.push(arr_temp);\r\n  }\r\n  return arr;\r\n});\r\n```\r\n\r\nYou may have noticed that each cell in my word matrix has a letter and a background color associated with. That is how i keep track of if a word is correct, or is correct\r\nis but at a wrong place or is incorrent.\r\n\r\nI then create another state with that keeps track of in which cell the user is entering characters at, like\r\n\r\n```ts\r\nconst [currentRowCol, setCurrentRowCol] = useState({ r: 0, c: 0 });\r\n```\r\n\r\nNext, I map the view with this matrix:\r\n\r\n```tsx\r\n<Box>\r\n  {wordMatrix.map((el, i) => {\r\n    const { r, c } = currentRowCol;\r\n    return (\r\n      <Box\r\n        key={i}\r\n        flexDirection=\"row\"\r\n        alignItems=\"center\"\r\n        justifyContent=\"center\"\r\n      >\r\n        {el.map((t, j) => (\r\n          <Box\r\n            key={j}\r\n            width={6}\r\n            height={2}\r\n            borderColor={r === i && c == j ? \"redBright\" : \"cyan\"}\r\n            b\r\n            orderStyle=\"single\"\r\n          >\r\n            <Text\r\n              bold\r\n              color=\"whiteBright\"\r\n              backgroundColor={wordMatrix[i][j].bgColor}\r\n              key={j}\r\n            >\r\n              {\" \" + wordMatrix[i][j].letter + \" \"}\r\n            </Text>\r\n          </Box>\r\n        ))}\r\n      </Box>\r\n    );\r\n  })}\r\n</Box>\r\n```\r\n\r\nI have defined some logic to determine what background color to give to the text.\r\n\r\nnext, I defined the keyboard like so\r\n\r\n```tsx\r\nconst keyboard = [\r\n  [\"Q\", \"W\", \"E\", \"R\", \"T\", \"Y\", \"U\", \"I\", \"O\", \"P\"],\r\n  [\"A\", \"S\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\"],\r\n  [\"Z\", \"X\", \"C\", \"V\", \"B\", \"N\", \"M\"],\r\n] as const;\r\n\r\n{\r\n  keyboard.map((el, i) => {\r\n    return (\r\n      <Box\r\n        key={i}\r\n        flexDirection=\"row\"\r\n        alignItems=\"center\"\r\n        justifyContent=\"center\"\r\n      >\r\n        {el.map((t, j) => {\r\n          // incorrectLetters is a state array that contains the incorrect letters\r\n          const color = incorrectLetters.find((ltr) => t === ltr)\r\n            ? \"gray\"\r\n            : \"white\";\r\n          return (\r\n            <Box key={j} width={6} alignItems=\"center\" height={2}>\r\n              <Text\r\n                backgroundColor={color}\r\n                color={color === \"white\" ? \"blackBright\" : \"whiteBright\"}\r\n                bold\r\n              >\r\n                {\"  \" + t + \"  \"}\r\n              </Text>\r\n            </Box>\r\n          );\r\n        })}\r\n      </Box>\r\n    );\r\n  });\r\n}\r\n```\r\n\r\nto generate a random word, I used the `randomWords` package like so:\r\n\r\n```ts\r\nconst getRWord = () => {\r\n  return randomWords({\r\n    exactly: 1,\r\n    maxLength: 5,\r\n  })[0].toUpperCase();\r\n};\r\n\r\nconst [word] = useState(() => {\r\n  let rword = getRWord();\r\n  while (rword.length !== 5) {\r\n    rword = getRWord();\r\n  }\r\n  return rword;\r\n});\r\n```\r\n\r\nNow, all that's required to do is to handle the input. For input, `react-ink` provides the `useInput` hook that takes a callback that fires when the user enters something to the command line.\r\n\r\n```ts\r\nuseInput((input, key) => {\r\n  input = input.toUpperCase();\r\n  if (key.return) {\r\n    let { c, r } = currentRowCol;\r\n    let wMatrix = [...wordMatrix];\r\n    let wordArr = word.split(\"\");\r\n    let arr = wMatrix[r];\r\n    let potentialArr = [];\r\n    arr.forEach((l, i) => {\r\n      let letter = l.letter;\r\n      let letterRandom = wordArr[i];\r\n      if (letter === letterRandom) {\r\n        l.bgColor = \"green\";\r\n        arr[i] = l;\r\n        potentialArr.forEach((el) => {\r\n          if (el.index !== i && el.descriptor.letter === l.letter) {\r\n            arr[el.index] = { ...el.descriptor, bgColor: \"gray\" };\r\n            setIncorrectLetters((prev) => [...prev, el.descriptor.letter]);\r\n          }\r\n        });\r\n      } else if (wordArr.find((rnd) => rnd === letter)) {\r\n        l.bgColor = \"yellow\";\r\n\r\n        arr[i] = l;\r\n        potentialArr.push({ descriptor: l, index: i });\r\n      } else {\r\n        setIncorrectLetters((prev) => [...prev, letter]);\r\n        l.bgColor = \"gray\";\r\n        arr[i] = l;\r\n      }\r\n    });\r\n\r\n    wMatrix[r] = [...arr];\r\n    setWordMatrix([...wMatrix]);\r\n    let correctAnswers = arr.filter((ar) => ar.bgColor === \"green\").length;\r\n    if (correctAnswers === 5) {\r\n      setGame((prev) => {\r\n        return { ...prev, completed: true, won: true };\r\n      });\r\n      exit();\r\n    }\r\n\r\n    r += 1;\r\n    c = 0;\r\n\r\n    if (r > 5) {\r\n      let correctAnswers = wordMatrix[5].filter(\r\n        (ar) => ar.bgColor === \"green\"\r\n      ).length;\r\n      if (correctAnswers < 5) {\r\n        setGame((prev) => {\r\n          return { ...prev, completed: true, won: false };\r\n        });\r\n      } else if (correctAnswers === 5) {\r\n        setGame((prev) => {\r\n          return { ...prev, completed: true, won: true };\r\n        });\r\n      }\r\n      exit();\r\n    }\r\n    setCurrentRowCol({ c, r });\r\n  } else if (key.backspace) {\r\n    let currArr = [...wordMatrix];\r\n\r\n    let { c, r } = currentRowCol;\r\n    currArr[r][c] = { ...currArr[r][c], letter: \"\" };\r\n    if (c !== 0) c -= 1;\r\n\r\n    setWordMatrix(() => [...currArr]);\r\n    setCurrentRowCol({ c, r });\r\n  } else if (input === keyboard.flat().find((el) => el === input)) {\r\n    let currArr = [...wordMatrix];\r\n\r\n    let { c, r } = currentRowCol;\r\n\r\n    currArr[r][c] = { ...currArr[r][c], letter: input };\r\n    if (c + 1 > 4) {\r\n      c = 4;\r\n    } else {\r\n      c += 1;\r\n    }\r\n    setWordMatrix(() => [...currArr]);\r\n    setCurrentRowCol({ c, r });\r\n  }\r\n});\r\n```\r\n\r\nEssentially what is being handled here is, when the user enters a letter, it gets validated and placed into a the current cell. the cell is then incremented to the right. When the user presses backspace, the letter is deleted from the cell and cell moves one to the left. Else, if the user presses `return` key, it moves over to the next row and what letters are correct/incorrent are validated. When the user has run out of all tries and has not won the game, the game's state will be set to `{won:false,completed:true}`.\r\n\r\nBasically that is what the game's logic is. You can check out the full source code in this [repo](https://github.com/portableCoder/Wordly).//]: <> (raw url: https://raw.githubusercontent.com/portableCoder/portableThoughts/main/blog/thought1.md)\r\n\r\nReact is one of the most popular front end frameworks out there. It supports a plethora of different platforms, but what you might not have known is that you\r\ncan even build a CLI application with react.\r\n\r\nThere are thousands of different wordle clones you can find online these days, mostly web-based. I wanted to recreate it too, but I had a different approach -- I wanted to make it a cli-based game. I also wanted to use react to make it, so I opted on using the great [React-Ink](https://github.com/vadimdemedes/ink) library which allows you to build react-based\r\nCLI-applications by utilizing a custom renderer for the command line.\r\n\r\nI started by initializing a 6x5 in a state like so:\r\n\r\n```ts\r\nconst [wordMatrix, setWordMatrix] = useState(() => {\r\n  let arr: Array<\r\n    Array<{\r\n      bgColor: LiteralUnion<typeof ForegroundColor, string>;\r\n      letter: string;\r\n    }>\r\n  > = [];\r\n  for (let index = 0; index < 6; index++) {\r\n    let arr_temp: Array<{\r\n      bgColor: LiteralUnion<typeof ForegroundColor, string>;\r\n      letter: string;\r\n    }> = [];\r\n    for (let j = 0; j < 5; j++) {\r\n      arr_temp.push({ bgColor: null, letter: \"\" });\r\n    }\r\n    arr.push(arr_temp);\r\n  }\r\n  return arr;\r\n});\r\n```\r\n\r\nYou may have noticed that each cell in my word matrix has a letter and a background color associated with. That is how i keep track of if a word is correct, or is correct\r\nis but at a wrong place or is incorrent.\r\n\r\nI then create another state with that keeps track of in which cell the user is entering characters at, like\r\n\r\n```ts\r\nconst [currentRowCol, setCurrentRowCol] = useState({ r: 0, c: 0 });\r\n```\r\n\r\nNext, I map the view with this matrix:\r\n\r\n```tsx\r\n<Box>\r\n  {wordMatrix.map((el, i) => {\r\n    const { r, c } = currentRowCol;\r\n    return (\r\n      <Box\r\n        key={i}\r\n        flexDirection=\"row\"\r\n        alignItems=\"center\"\r\n        justifyContent=\"center\"\r\n      >\r\n        {el.map((t, j) => (\r\n          <Box\r\n            key={j}\r\n            width={6}\r\n            height={2}\r\n            borderColor={r === i && c == j ? \"redBright\" : \"cyan\"}\r\n            b\r\n            orderStyle=\"single\"\r\n          >\r\n            <Text\r\n              bold\r\n              color=\"whiteBright\"\r\n              backgroundColor={wordMatrix[i][j].bgColor}\r\n              key={j}\r\n            >\r\n              {\" \" + wordMatrix[i][j].letter + \" \"}\r\n            </Text>\r\n          </Box>\r\n        ))}\r\n      </Box>\r\n    );\r\n  })}\r\n</Box>\r\n```\r\n\r\nI have defined some logic to determine what background color to give to the text.\r\n\r\nnext, I defined the keyboard like so\r\n\r\n```tsx\r\nconst keyboard = [\r\n  [\"Q\", \"W\", \"E\", \"R\", \"T\", \"Y\", \"U\", \"I\", \"O\", \"P\"],\r\n  [\"A\", \"S\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\"],\r\n  [\"Z\", \"X\", \"C\", \"V\", \"B\", \"N\", \"M\"],\r\n] as const;\r\n\r\n{\r\n  keyboard.map((el, i) => {\r\n    return (\r\n      <Box\r\n        key={i}\r\n        flexDirection=\"row\"\r\n        alignItems=\"center\"\r\n        justifyContent=\"center\"\r\n      >\r\n        {el.map((t, j) => {\r\n          // incorrectLetters is a state array that contains the incorrect letters\r\n          const color = incorrectLetters.find((ltr) => t === ltr)\r\n            ? \"gray\"\r\n            : \"white\";\r\n          return (\r\n            <Box key={j} width={6} alignItems=\"center\" height={2}>\r\n              <Text\r\n                backgroundColor={color}\r\n                color={color === \"white\" ? \"blackBright\" : \"whiteBright\"}\r\n                bold\r\n              >\r\n                {\"  \" + t + \"  \"}\r\n              </Text>\r\n            </Box>\r\n          );\r\n        })}\r\n      </Box>\r\n    );\r\n  });\r\n}\r\n```\r\n\r\nto generate a random word, I used the `randomWords` package like so:\r\n\r\n```ts\r\nconst getRWord = () => {\r\n  return randomWords({\r\n    exactly: 1,\r\n    maxLength: 5,\r\n  })[0].toUpperCase();\r\n};\r\n\r\nconst [word] = useState(() => {\r\n  let rword = getRWord();\r\n  while (rword.length !== 5) {\r\n    rword = getRWord();\r\n  }\r\n  return rword;\r\n});\r\n```\r\n\r\nNow, all that's required to do is to handle the input. For input, `react-ink` provides the `useInput` hook that takes a callback that fires when the user enters something to the command line.\r\n\r\n```ts\r\nuseInput((input, key) => {\r\n  input = input.toUpperCase();\r\n  if (key.return) {\r\n    let { c, r } = currentRowCol;\r\n    let wMatrix = [...wordMatrix];\r\n    let wordArr = word.split(\"\");\r\n    let arr = wMatrix[r];\r\n    let potentialArr = [];\r\n    arr.forEach((l, i) => {\r\n      let letter = l.letter;\r\n      let letterRandom = wordArr[i];\r\n      if (letter === letterRandom) {\r\n        l.bgColor = \"green\";\r\n        arr[i] = l;\r\n        potentialArr.forEach((el) => {\r\n          if (el.index !== i && el.descriptor.letter === l.letter) {\r\n            arr[el.index] = { ...el.descriptor, bgColor: \"gray\" };\r\n            setIncorrectLetters((prev) => [...prev, el.descriptor.letter]);\r\n          }\r\n        });\r\n      } else if (wordArr.find((rnd) => rnd === letter)) {\r\n        l.bgColor = \"yellow\";\r\n\r\n        arr[i] = l;\r\n        potentialArr.push({ descriptor: l, index: i });\r\n      } else {\r\n        setIncorrectLetters((prev) => [...prev, letter]);\r\n        l.bgColor = \"gray\";\r\n        arr[i] = l;\r\n      }\r\n    });\r\n\r\n    wMatrix[r] = [...arr];\r\n    setWordMatrix([...wMatrix]);\r\n    let correctAnswers = arr.filter((ar) => ar.bgColor === \"green\").length;\r\n    if (correctAnswers === 5) {\r\n      setGame((prev) => {\r\n        return { ...prev, completed: true, won: true };\r\n      });\r\n      exit();\r\n    }\r\n\r\n    r += 1;\r\n    c = 0;\r\n\r\n    if (r > 5) {\r\n      let correctAnswers = wordMatrix[5].filter(\r\n        (ar) => ar.bgColor === \"green\"\r\n      ).length;\r\n      if (correctAnswers < 5) {\r\n        setGame((prev) => {\r\n          return { ...prev, completed: true, won: false };\r\n        });\r\n      } else if (correctAnswers === 5) {\r\n        setGame((prev) => {\r\n          return { ...prev, completed: true, won: true };\r\n        });\r\n      }\r\n      exit();\r\n    }\r\n    setCurrentRowCol({ c, r });\r\n  } else if (key.backspace) {\r\n    let currArr = [...wordMatrix];\r\n\r\n    let { c, r } = currentRowCol;\r\n    currArr[r][c] = { ...currArr[r][c], letter: \"\" };\r\n    if (c !== 0) c -= 1;\r\n\r\n    setWordMatrix(() => [...currArr]);\r\n    setCurrentRowCol({ c, r });\r\n  } else if (input === keyboard.flat().find((el) => el === input)) {\r\n    let currArr = [...wordMatrix];\r\n\r\n    let { c, r } = currentRowCol;\r\n\r\n    currArr[r][c] = { ...currArr[r][c], letter: input };\r\n    if (c + 1 > 4) {\r\n      c = 4;\r\n    } else {\r\n      c += 1;\r\n    }\r\n    setWordMatrix(() => [...currArr]);\r\n    setCurrentRowCol({ c, r });\r\n  }\r\n});\r\n```\r\n\r\nEssentially what is being handled here is, when the user enters a letter, it gets validated and placed into a the current cell. the cell is then incremented to the right. When the user presses backspace, the letter is deleted from the cell and cell moves one to the left. Else, if the user presses `return` key, it moves over to the next row and what letters are correct/incorrent are validated. When the user has run out of all tries and has not won the game, the game's state will be set to `{won:false,completed:true}`.\r\n\r\nBasically that is what the game's logic is. You can check out the full source code in this [repo](https://github.com/portableCoder/Wordly).\r\n","slug":"How-I-Made-Wordly"}},"__N_SSG":true}