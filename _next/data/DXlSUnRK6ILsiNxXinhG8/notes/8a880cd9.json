{"pageProps":{"pageContext":{"content":"\r\n## Test\r\n```ts\r\nclass MonotonicStack{\r\n\r\n    stck : number[] = []\r\n\r\n    push(val:number){\r\n\r\n       let stck = this.stck\r\n\r\n       while(this.top() < val){\r\n\r\n           stck.pop()\r\n\r\n       }\r\n\r\n       stck.push(val)\r\n\r\n  \r\n\r\n    }\r\n\r\n    top(){\r\n\r\n        let stck = this.stck\r\n\r\n        return stck[stck.length - 1]\r\n\r\n    }\r\n\r\n}\r\n```\r\n## Dynamic Sliding Window\r\n```ts\r\nfunction subArraySumGt(arr:number[],s:number):number{\r\n\r\n    let res = Number.MAX_SAFE_INTEGER\r\n\r\n    let l = 0\r\n\r\n    let r = 0\r\n\r\n    let temp = 0\r\n\r\n    while(r < arr.length){\r\n\r\n        temp+=arr[r]\r\n\r\n        while( (l < r) && temp>= s){\r\n\r\n            res = Math.min(res,(r-l)+1)\r\n\r\n            temp-=arr[l]\r\n\r\n            l++\r\n\r\n        }\r\n\r\n        r++\r\n\r\n    }\r\n\r\n    return res\r\n\r\n}\r\n```\r\n# Sieve of Eratosthenes\r\n```ts\r\nfunction primeSieve(n:number){\r\n\r\n    let nPrime = 0\r\n\r\n    if( n <= 1){\r\n\r\n        return 0\r\n\r\n    }\r\n\r\n    let l = []\r\n\r\n    for(let i = 2; i <= n; i++){\r\n\r\n        l[i] = true\r\n\r\n    }\r\n\r\n    for(let i = 2; i <= Math.sqrt(n); i++){\r\n\r\n        if(l[i] === true){\r\n\r\n            for(let j = i*i; j <= n; j+=i ){\r\n\r\n                l[j] = false\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    for(let b = 2; b<=n;b++){\r\n\r\n        if(l[b] === true){\r\n\r\n            nPrime++\r\n\r\n        }\r\n\r\n    }\r\n\r\n  \r\n\r\n    return nPrime\r\n\r\n}\r\n\r\n```\r\n## Implementation of A Max Heap\r\n```ts\r\nclass Heap{\r\n\r\n     heapArray:number[] = []\r\n\r\n     constructor(heapArray:number[]){\r\n\r\n         this.heapArray = heapArray\r\n\r\n         this.build_max_heap(heapArray)\r\n\r\n     }\r\n\r\n     //[100, 12, 89, 9, 5, 25, 65, 4, 6, 3, 0, 22, 20, 1, 28, -5]\r\n\r\n   maxHeapify(arr:number[], n:number, i:number)\r\n\r\n    {\r\n\r\n        const size = arr.length\r\n\r\n        const l = 2*i\r\n\r\n        const r = (2*i) + 1\r\n\r\n        let largest = i    \r\n\r\n        if(l < size && arr[l] > arr[i]){\r\n\r\n            largest = l\r\n\r\n        }\r\n\r\n        if(r <  size && arr[r]>arr[largest]){\r\n\r\n            largest = r\r\n\r\n        }\r\n\r\n  \r\n\r\n            if(largest!==i){\r\n\r\n                let temp = a[largest]\r\n\r\n                a[largest] = a[i]\r\n\r\n                a[i] = temp\r\n\r\n  \r\n\r\n                this.maxHeapify(arr,n,largest)\r\n\r\n            }\r\n\r\n        }\r\n\r\n     build_max_heap(a:number[]){\r\n\r\n         let size = a.length\r\n\r\n         for(let i = Math.floor(size/2); i > 0; i--){\r\n\r\n             this.maxHeapify(a,size,i)\r\n\r\n         }\r\n\r\n  \r\n\r\n     }\r\n\r\n    isHeap(arr: number[], i: number, n: number): boolean {\r\n\r\n        // If (2 * i) + 1 >= n, then leaf node, so return true\r\n\r\n        if (i >= (n - 1) / 2) {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n  \r\n\r\n        // If an internal node and\r\n\r\n        // is greater than its\r\n\r\n        // children, and same is\r\n\r\n        // recursively true for the\r\n\r\n        // children\r\n\r\n        if (arr[i] >= arr[2 * i + 1]\r\n\r\n            && arr[i] >= arr[2 * i + 2]\r\n\r\n            && this.isHeap(arr, 2 * i + 1, n)\r\n\r\n            && this.isHeap(arr, 2 * i + 2, n)) {\r\n\r\n            return true;\r\n\r\n        }\r\n\r\n  \r\n\r\n        return false;\r\n\r\n    }\r\n\r\n  \r\n  \r\n\r\n}\r\n\r\nlet a = [null, 0, 5, 20, 6, 12, 65, 1, 4, 9, 3, 89, 22, 25, 28, 10]\r\n\r\n  \r\n  \r\n\r\nlet heap = new Heap(a)\r\n\r\nheap.heapArray.push(100,-5,10000)\r\n\r\nheap.build_max_heap(heap.heapArray)\r\n\r\n  \r\n\r\nconsole.log(heap.heapArray.slice(1))\r\n\r\nconsole.log(\"isHeap: \" + heap.isHeap(heap.heapArray,1,heap.heapArray.length-1))\r\n```\r\n\r\n\r\n## Level Order Traversal Of A Binary Tree\r\n```js\r\n  \r\nvar levelOrder = function(root) {\r\n    if(!root){\r\n        return [];\r\n    }\r\n    let q = [root]\r\n    let res = []\r\n    \r\n    while (q.length > 0){\r\n        let t = []\r\n        let l = q.length\r\n        for(let i = 0; i < l;i++){\r\n            let node = q.shift()\r\n            if(node){\r\n                t.push(node.val)\r\n                q.push(node.left,node.right)\r\n            }\r\n        }\r\n        \r\n        if(t.length !== 0){\r\n            res.push(t)\r\n        }\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n## Implementation of a graph w/ traversal (BFS & DFS)\r\n```ts\r\nclass Graph <T>{\r\n\r\n    adjacencyList = new Map<T,T[]>()\r\n\r\n  constructor() {\r\n\r\n  }\r\n\r\n  addNode(val:T){\r\n\r\n    this.adjacencyList.set(val,[])\r\n\r\n  }\r\n\r\n  addEdge(source:T,destination:T){\r\n\r\n    let map = this.adjacencyList\r\n\r\n    let a = map.get(source)\r\n\r\n    let b = map.get(destination)\r\n\r\n    if(a && b){\r\n\r\n      a.push(destination)\r\n\r\n      b.push(source)\r\n\r\n    }\r\n\r\n  \r\n\r\n  }\r\n\r\n  bfs(start:T,end:T){\r\n\r\n    let visited = new Set<T>()\r\n\r\n    let q : T[] = [start]\r\n\r\n    while (q.length > 0){\r\n\r\n      let node = q.shift()\r\n\r\n      console.log(`|node --> ${node}`)\r\n\r\n      if(node){\r\n\r\n        let adj = this.adjacencyList.get(node)\r\n\r\n        for(let el of adj){\r\n\r\n        console.log(`|-child --> ${el}`)\r\n\r\n  \r\n\r\n          if(el === end){\r\n\r\n            return true\r\n\r\n          }\r\n\r\n          if(!visited.has(el)){\r\n\r\n            visited.add(el)\r\n\r\n            q.push(el)\r\n\r\n          }\r\n\r\n  \r\n\r\n        }\r\n\r\n      }\r\n\r\n  \r\n\r\n    }\r\n\r\n    return false\r\n\r\n  \r\n\r\n  }\r\n\r\n  dfs(start:T,end:T,visited = new Set<T>()):boolean{\r\n\r\n    visited.add(start)\r\n\r\n    let adj = this.adjacencyList.get(start)\r\n\r\n    console.log(`|node --> ${start} `)\r\n\r\n    if(adj){\r\n\r\n      for(let node of adj){\r\n\r\n      console.log(`|-child --> ${node} `)\r\n\r\n  \r\n\r\n        if(node === end){\r\n\r\n          return true\r\n\r\n        }\r\n\r\n        if(!visited.has(node)){\r\n\r\n          let v = this.dfs(node,end,visited)\r\n\r\n          if(v === true){\r\n\r\n            return v\r\n\r\n          }\r\n\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n  \r\n\r\n    return false\r\n\r\n  \r\n\r\n  }\r\n\r\n  \r\n\r\n}\r\n\r\nlet g = new Graph<number>()\r\n\r\ng.addNode(1)\r\n\r\ng.addNode(2)\r\n\r\ng.addNode(3)\r\n\r\ng.addNode(5)\r\n\r\ng.addNode(6)\r\n\r\ng.addNode(7)\r\n\r\n  \r\n  \r\n\r\ng.addEdge(1,2)\r\n\r\ng.addEdge(2,5)\r\n\r\ng.addEdge(1,3)\r\n\r\ng.addEdge(3,6)\r\n\r\ng.addEdge(3,7)\r\n\r\nconsole.log(g.dfs(1,8))\r\n\r\n```\r\n## Power set of a given set\r\n```ts\r\nconst decToBin = (dec:number)=>{\r\n\r\n    return (dec >>> 0).toString(2)\r\n\r\n}\r\n\r\nconst generateBitStrings = (n:number)=>{\r\n\r\n    let len = Math.pow(2,n)\r\n\r\n    let arr : string[] = []\r\n\r\n    let str = \"\"\r\n\r\n    for(let i = 0 ; i < n; i++){\r\n\r\n        str+=\"0\"\r\n\r\n    }\r\n\r\n    arr.push(str)\r\n\r\n    for(let i = 1; i < len; i++){\r\n\r\n        let p = i\r\n\r\n        arr.push(decToBin(p).padStart(n,\"0\"))\r\n\r\n    }\r\n\r\n    return arr\r\n\r\n  \r\n\r\n}\r\n\r\nfunction generatePowerSet<T>(subset:Set<T>){\r\n\r\n    let arr = [...subset]\r\n\r\n    let bitstrings = generateBitStrings(arr.length)\r\n\r\n    console.log(bitstrings)\r\n\r\n    let powerset : Set<Set<T>> = new Set()\r\n\r\n    bitstrings.forEach((el)=>{\r\n\r\n        let temp_arr : Set<T> = new Set()\r\n\r\n        for(let i = 0; i < el.length;i++){\r\n\r\n            if(el[i] === \"1\"){\r\n\r\n                console.log('yes',el,arr[i])\r\n\r\n                temp_arr.add(arr[i])\r\n\r\n            }\r\n\r\n        }\r\n\r\n        powerset.add(temp_arr)\r\n\r\n    })\r\n\r\n    return powerset\r\n\r\n}\r\n\r\nconsole.log(generatePowerSet(new Set([1,2,3])))\r\n```\r\n## Monotonic Stack\r\n```ts\r\nclass MonotonicStack{\r\n\r\n    popLimit :number = 0\r\n\r\n    public a : number[] = []\r\n\r\n    constructor(popLimit:number){\r\n\r\n        this.popLimit = popLimit\r\n\r\n    }\r\n\r\n  \r\n\r\n    public push(item:number){\r\n\r\n        let stck = this.a\r\n\r\n        if(stck[stck.length - 1] > item){\r\n\r\n            while(stck[stck.length - 1]>item && this.popLimit > 0){\r\n\r\n                this.pop()\r\n\r\n  \r\n\r\n                this.popLimit--\r\n\r\n            }\r\n\r\n        }\r\n\r\n        this.a.push(item)\r\n\r\n  \r\n  \r\n\r\n    }\r\n\r\n    public peek(){\r\n\r\n        return this.a[this.a.length - 1]\r\n\r\n    }\r\n\r\n    public pop(){\r\n\r\n        return this.a.pop();\r\n\r\n    }\r\n\r\n    public getStack(){\r\n\r\n        return this.a\r\n\r\n    }\r\n\r\n}\r\n\r\nlet s = new MonotonicStack(3)\r\n\r\nlet str = '1432219'\r\n\r\nfor (let c of str){\r\n\r\n    s.push(parseInt(c))\r\n\r\n}\r\n```\r\n## Insertion sort \r\n- [[introduction-to-algorithms-3rd-edition.pdf#page=39]]\r\n## Two Pointers\r\n```ts\r\nlet arr : number|array = []\r\nlet ptr1 = 0\r\nlet ptr2 = arr\r\nwhile(ptr2>ptr1){\r\n\tlet sum = arr[ptr1]+arr[ptr2]\r\n\tif(sum === target){\r\n\t\treturn [ptr1,ptr2]\r\n\t}\r\n\tif(sum < target){\r\n\t\tptr1++\r\n\t}else{\r\n\t\tptr1--\r\n\t}\r\n}\r\n\r\n```\r\n\r\n## Kadane's Algorithm\r\n```ts\r\nconst kadane = (arr:number[])=>{\r\n\r\n    let curSum = 0\r\n\r\n    let maxSum = Number.MIN_VALUE\r\n\r\n    for(let i = 0 ; i < arr.length;i++){\r\n\r\n        curSum+=arr[i]\r\n\r\n        if(curSum>maxSum){\r\n\r\n            maxSum = curSum\r\n\r\n        }\r\n\r\n        if(curSum<0){\r\n\r\n            curSum = 0\r\n\r\n        }\r\n\r\n    }\r\n\r\n    return maxSum\r\n\r\n  \r\n\r\n}\r\n\r\n```\r\n## Heap's algorithm\r\n```ts\r\nlet c:number[][]=[]\r\n\r\nconst permutate = (k:number, arr:any[])=>{\r\n\r\n    if(k === 1){\r\n\r\n        c.push(arr)\r\n\r\n        return;\r\n\r\n    }else{\r\n\r\n        permutate(k-1,arr)\r\n\r\n        for(let i = 0;  i < k - 1; i++){\r\n\r\n            if(k % 2 === 0){\r\n\r\n                let temp = arr[k-1]\r\n\r\n                arr[k-1] = arr[i]\r\n\r\n                arr[i] = temp\r\n\r\n  \r\n\r\n            }else{\r\n\r\n                let temp = arr[0]\r\n\r\n                arr[0] = arr[k-1]\r\n\r\n                arr[k-1] = temp\r\n\r\n            }\r\n\r\n  \r\n\r\n            permutate(k-1,arr)\r\n\r\n  \r\n\r\n        }\r\n\r\n    }\r\n\r\n    return c\r\n\r\n}\r\n\r\n```\r\n## Merge Sort\r\n```ts\r\nlet m_arr = [3,51,6,3,5,36,7]\r\n\r\nconst mergeSort  = (m:number[]):number[]=>{\r\n\r\n    let mid = Math.floor(m.length/2)\r\n\r\n  \r\n\r\n    if(m.length === 1){\r\n\r\n        return m\r\n\r\n    }\r\n\r\n    let l = mergeSort(m.slice(0,mid))\r\n\r\n    let r = mergeSort(m.slice(mid))\r\n\r\n  \r\n\r\n    return merge(l,r)\r\n\r\n}\r\n\r\nconst merge = (a:number[],b:number[]):number[]=>{\r\n\r\n    let c = []\r\n\r\n    while (a.length!== 0 && b.length !== 0){\r\n\r\n        if(a[0]>b[0]){\r\n\r\n            c.push(b[0])\r\n\r\n            b.splice(0,1)\r\n\r\n  \r\n\r\n        }else{\r\n\r\n            c.push(a[0])\r\n\r\n            a.splice(0,1)\r\n\r\n        }\r\n\r\n    }\r\n\r\n    while(a.length !== 0){\r\n\r\n        c.push(a[0])\r\n\r\n        a.splice(0,1)\r\n\r\n    }\r\n\r\n    while(b.length !== 0){\r\n\r\n        c.push(b[0])\r\n\r\n        b.splice(0,1)\r\n\r\n    }\r\n\r\n    return c\r\n\r\n}\r\n\r\n  \r\n  \r\n  \r\n\r\nconsole.log(mergeSort(m_arr))\r\n```\r\n\r\n## Selection Sort\r\n```ts\r\nconst SelectionSort = (arr:number[])=>{\r\n\r\n    for(let i = 0 ; i < arr.length ;i ++ ){\r\n\r\n        let cur = arr[i]\r\n\r\n        let i2 = null\r\n\r\n        for (let j = i+1; j < arr.length;j++){\r\n\r\n            if(arr[j]<cur){\r\n\r\n                i2 = j\r\n\r\n            }\r\n\r\n  \r\n\r\n        }\r\n\r\n        if(i2){\r\n\r\n            [arr[i],arr[i2]] = [arr[i2],arr[i]]\r\n\r\n  \r\n\r\n        }\r\n\r\n  \r\n\r\n    }\r\n\r\n    return arr\r\n\r\n}\r\n```","uid":"8a880cd9","date":1708586817.278}},"__N_SSG":true}