<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" type="image/x-icon" href="/portableThoughts/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/portableThoughts/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/portableThoughts/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/portableThoughts/favicon-16x16.png"/><title>portableThoughts</title><meta name="next-head-count" content="4"/><link rel="preload" href="/portableThoughts/_next/static/css/4547dfa5c33d1e27.css" as="style"/><link rel="stylesheet" href="/portableThoughts/_next/static/css/4547dfa5c33d1e27.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/portableThoughts/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/portableThoughts/_next/static/chunks/webpack-5b5d7ff71da02426.js" defer=""></script><script src="/portableThoughts/_next/static/chunks/framework-9b5d6ec4444c80fa.js" defer=""></script><script src="/portableThoughts/_next/static/chunks/main-7482ba1e277944c2.js" defer=""></script><script src="/portableThoughts/_next/static/chunks/pages/_app-8d2846c69bccfb40.js" defer=""></script><script src="/portableThoughts/_next/static/chunks/545f34e4-1a5a8fc6f15a1658.js" defer=""></script><script src="/portableThoughts/_next/static/chunks/0c428ae2-13ec36fc07d8bdd8.js" defer=""></script><script src="/portableThoughts/_next/static/chunks/d7eeaac4-a69db188334f6e15.js" defer=""></script><script src="/portableThoughts/_next/static/chunks/926-f984f8320791dce6.js" defer=""></script><script src="/portableThoughts/_next/static/chunks/664-ac1349529b76e794.js" defer=""></script><script src="/portableThoughts/_next/static/chunks/pages/index-d3f6c75fe7faffa8.js" defer=""></script><script src="/portableThoughts/_next/static/DXlSUnRK6ILsiNxXinhG8/_buildManifest.js" defer=""></script><script src="/portableThoughts/_next/static/DXlSUnRK6ILsiNxXinhG8/_ssgManifest.js" defer=""></script></head><body><div id="__next"><main class="h-full w-screen text-black dark:text-white px-3 md+:px-12 md:px-20"><header style="background-color:#111216" class="flex justify-between w-full text-xl md:text-3xl font-bold py-1 px-3 md:py-2 md:px-6 text-black dark:text-white "><div class="flex items-center justify-center gap-x-1"><i class="m-auto md:my-0 hover:animate-bounce"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 512 512" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M256 73.32L74.6 155.1l82.3 37.1 173.2-85.5L256 73.32zm95.4 42.98l-173.2 85.5 77.8 35.1 181.4-81.8-86-38.8zM61.7 169v182L247 434.6v-182L61.7 169zm388.6 0L265 252.6v182L450.3 351V169z"></path></svg></i><h1 class="hover:animate-pulse flex "><p class="text-green-500">_</p> </h1></div><div class="undefined dark:bg-transparent  w-16 h-16 rounded-md flex items-center justify-center transform transition-all duration-200 dark:text-white text-black rotate-0  "><button id="theme-button" role="theme-button" class="w-min h-min"> <i class=""><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278z"></path><path d="M10.794 3.148a.217.217 0 0 1 .412 0l.387 1.162c.173.518.579.924 1.097 1.097l1.162.387a.217.217 0 0 1 0 .412l-1.162.387a1.734 1.734 0 0 0-1.097 1.097l-.387 1.162a.217.217 0 0 1-.412 0l-.387-1.162A1.734 1.734 0 0 0 9.31 6.593l-1.162-.387a.217.217 0 0 1 0-.412l1.162-.387a1.734 1.734 0 0 0 1.097-1.097l.387-1.162zM13.863.099a.145.145 0 0 1 .274 0l.258.774c.115.346.386.617.732.732l.774.258a.145.145 0 0 1 0 .274l-.774.258a1.156 1.156 0 0 0-.732.732l-.258.774a.145.145 0 0 1-.274 0l-.258-.774a1.156 1.156 0 0 0-.732-.732l-.774-.258a.145.145 0 0 1 0-.274l.774-.258c.346-.115.617-.386.732-.732L13.863.1z"></path></svg></i></button></div></header><div style="height:80vh" class="flex flex-col md:grid grid-cols-6 h-screen md:h-auto justify-center -my-16 md:-my-0"><div class="col-span-4 p-2 "><img style="height:70vh" alt="mainImage" src="https://github.com/portableCoder/Wordly/raw/main/source/react.gif" class="transition-all duration-300 w-full object-cover rounded-md  opacity-100" placeholder="empty"/></div><div style="height:70vh" class="col-span-2 p-2"><div class=" text-gray-500 dark:text-gray-300">01/02/2022</div><div class="text-3xl">How I Created A CLI Based Wordle Clone With React</div><div class="text-xl">Meet wordly</div><div class="w-full flex justify-end items-end h-full -my-6 md:my-auto "><a class="rounded-md my-8 md:my-28 flex items-center justify-center h-16 text-center bg-sky-500 w-full md:w-min px-6 whitespace-nowrap py-3 text-xl md:text-2xl transition-all duration-500 hover:bg-green-500 text-white " href="/portableThoughts/thoughts/How-I-Made-Wordly">Read</a></div></div></div><div class="w-full h-full my-16 flex flex-col md:grid grid-cols-2 gap-3 gap-y-16 md:gap-6 py-16 px-3 justify-center items-center overflow-y-hidden"><div class="md:col-span-2 col-span-1"><div class="w-full py-6 relative -my-2"><div class="w-full h-full flex z-50 text-3xl p-2 my-16 ">Oops.. that&#x27;s all for now</div></div></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"thoughtsData":[{"image":"https://github.com/portableCoder/Wordly/raw/main/source/react.gif","date":"01/02/2022","title":"How I Created A CLI Based Wordle Clone With React","description":"Meet wordly","md":"\r\nReact is one of the most popular front end frameworks out there. It supports a plethora of different platforms, but what you might not have known is that you\r\ncan even build a CLI application with react.\r\n\r\nThere are thousands of different wordle clones you can find online these days, mostly web-based. I wanted to recreate it too, but I had a different approach -- I wanted to make it a cli-based game. I also wanted to use react to make it, so I opted on using the great [React-Ink](https://github.com/vadimdemedes/ink) library which allows you to build react-based\r\nCLI-applications by utilizing a custom renderer for the command line.\r\n\r\nI started by initializing a 6x5 in a state like so:\r\n\r\n```ts\r\nconst [wordMatrix, setWordMatrix] = useState(() =\u003e {\r\n  let arr: Array\u003c\r\n    Array\u003c{\r\n      bgColor: LiteralUnion\u003ctypeof ForegroundColor, string\u003e;\r\n      letter: string;\r\n    }\u003e\r\n  \u003e = [];\r\n  for (let index = 0; index \u003c 6; index++) {\r\n    let arr_temp: Array\u003c{\r\n      bgColor: LiteralUnion\u003ctypeof ForegroundColor, string\u003e;\r\n      letter: string;\r\n    }\u003e = [];\r\n    for (let j = 0; j \u003c 5; j++) {\r\n      arr_temp.push({ bgColor: null, letter: \"\" });\r\n    }\r\n    arr.push(arr_temp);\r\n  }\r\n  return arr;\r\n});\r\n```\r\n\r\nYou may have noticed that each cell in my word matrix has a letter and a background color associated with. That is how i keep track of if a word is correct, or is correct\r\nis but at a wrong place or is incorrent.\r\n\r\nI then create another state with that keeps track of in which cell the user is entering characters at, like\r\n\r\n```ts\r\nconst [currentRowCol, setCurrentRowCol] = useState({ r: 0, c: 0 });\r\n```\r\n\r\nNext, I map the view with this matrix:\r\n\r\n```tsx\r\n\u003cBox\u003e\r\n  {wordMatrix.map((el, i) =\u003e {\r\n    const { r, c } = currentRowCol;\r\n    return (\r\n      \u003cBox\r\n        key={i}\r\n        flexDirection=\"row\"\r\n        alignItems=\"center\"\r\n        justifyContent=\"center\"\r\n      \u003e\r\n        {el.map((t, j) =\u003e (\r\n          \u003cBox\r\n            key={j}\r\n            width={6}\r\n            height={2}\r\n            borderColor={r === i \u0026\u0026 c == j ? \"redBright\" : \"cyan\"}\r\n            b\r\n            orderStyle=\"single\"\r\n          \u003e\r\n            \u003cText\r\n              bold\r\n              color=\"whiteBright\"\r\n              backgroundColor={wordMatrix[i][j].bgColor}\r\n              key={j}\r\n            \u003e\r\n              {\" \" + wordMatrix[i][j].letter + \" \"}\r\n            \u003c/Text\u003e\r\n          \u003c/Box\u003e\r\n        ))}\r\n      \u003c/Box\u003e\r\n    );\r\n  })}\r\n\u003c/Box\u003e\r\n```\r\n\r\nI have defined some logic to determine what background color to give to the text.\r\n\r\nnext, I defined the keyboard like so\r\n\r\n```tsx\r\nconst keyboard = [\r\n  [\"Q\", \"W\", \"E\", \"R\", \"T\", \"Y\", \"U\", \"I\", \"O\", \"P\"],\r\n  [\"A\", \"S\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\"],\r\n  [\"Z\", \"X\", \"C\", \"V\", \"B\", \"N\", \"M\"],\r\n] as const;\r\n\r\n{\r\n  keyboard.map((el, i) =\u003e {\r\n    return (\r\n      \u003cBox\r\n        key={i}\r\n        flexDirection=\"row\"\r\n        alignItems=\"center\"\r\n        justifyContent=\"center\"\r\n      \u003e\r\n        {el.map((t, j) =\u003e {\r\n          // incorrectLetters is a state array that contains the incorrect letters\r\n          const color = incorrectLetters.find((ltr) =\u003e t === ltr)\r\n            ? \"gray\"\r\n            : \"white\";\r\n          return (\r\n            \u003cBox key={j} width={6} alignItems=\"center\" height={2}\u003e\r\n              \u003cText\r\n                backgroundColor={color}\r\n                color={color === \"white\" ? \"blackBright\" : \"whiteBright\"}\r\n                bold\r\n              \u003e\r\n                {\"  \" + t + \"  \"}\r\n              \u003c/Text\u003e\r\n            \u003c/Box\u003e\r\n          );\r\n        })}\r\n      \u003c/Box\u003e\r\n    );\r\n  });\r\n}\r\n```\r\n\r\nto generate a random word, I used the `randomWords` package like so:\r\n\r\n```ts\r\nconst getRWord = () =\u003e {\r\n  return randomWords({\r\n    exactly: 1,\r\n    maxLength: 5,\r\n  })[0].toUpperCase();\r\n};\r\n\r\nconst [word] = useState(() =\u003e {\r\n  let rword = getRWord();\r\n  while (rword.length !== 5) {\r\n    rword = getRWord();\r\n  }\r\n  return rword;\r\n});\r\n```\r\n\r\nNow, all that's required to do is to handle the input. For input, `react-ink` provides the `useInput` hook that takes a callback that fires when the user enters something to the command line.\r\n\r\n```ts\r\nuseInput((input, key) =\u003e {\r\n  input = input.toUpperCase();\r\n  if (key.return) {\r\n    let { c, r } = currentRowCol;\r\n    let wMatrix = [...wordMatrix];\r\n    let wordArr = word.split(\"\");\r\n    let arr = wMatrix[r];\r\n    let potentialArr = [];\r\n    arr.forEach((l, i) =\u003e {\r\n      let letter = l.letter;\r\n      let letterRandom = wordArr[i];\r\n      if (letter === letterRandom) {\r\n        l.bgColor = \"green\";\r\n        arr[i] = l;\r\n        potentialArr.forEach((el) =\u003e {\r\n          if (el.index !== i \u0026\u0026 el.descriptor.letter === l.letter) {\r\n            arr[el.index] = { ...el.descriptor, bgColor: \"gray\" };\r\n            setIncorrectLetters((prev) =\u003e [...prev, el.descriptor.letter]);\r\n          }\r\n        });\r\n      } else if (wordArr.find((rnd) =\u003e rnd === letter)) {\r\n        l.bgColor = \"yellow\";\r\n\r\n        arr[i] = l;\r\n        potentialArr.push({ descriptor: l, index: i });\r\n      } else {\r\n        setIncorrectLetters((prev) =\u003e [...prev, letter]);\r\n        l.bgColor = \"gray\";\r\n        arr[i] = l;\r\n      }\r\n    });\r\n\r\n    wMatrix[r] = [...arr];\r\n    setWordMatrix([...wMatrix]);\r\n    let correctAnswers = arr.filter((ar) =\u003e ar.bgColor === \"green\").length;\r\n    if (correctAnswers === 5) {\r\n      setGame((prev) =\u003e {\r\n        return { ...prev, completed: true, won: true };\r\n      });\r\n      exit();\r\n    }\r\n\r\n    r += 1;\r\n    c = 0;\r\n\r\n    if (r \u003e 5) {\r\n      let correctAnswers = wordMatrix[5].filter(\r\n        (ar) =\u003e ar.bgColor === \"green\"\r\n      ).length;\r\n      if (correctAnswers \u003c 5) {\r\n        setGame((prev) =\u003e {\r\n          return { ...prev, completed: true, won: false };\r\n        });\r\n      } else if (correctAnswers === 5) {\r\n        setGame((prev) =\u003e {\r\n          return { ...prev, completed: true, won: true };\r\n        });\r\n      }\r\n      exit();\r\n    }\r\n    setCurrentRowCol({ c, r });\r\n  } else if (key.backspace) {\r\n    let currArr = [...wordMatrix];\r\n\r\n    let { c, r } = currentRowCol;\r\n    currArr[r][c] = { ...currArr[r][c], letter: \"\" };\r\n    if (c !== 0) c -= 1;\r\n\r\n    setWordMatrix(() =\u003e [...currArr]);\r\n    setCurrentRowCol({ c, r });\r\n  } else if (input === keyboard.flat().find((el) =\u003e el === input)) {\r\n    let currArr = [...wordMatrix];\r\n\r\n    let { c, r } = currentRowCol;\r\n\r\n    currArr[r][c] = { ...currArr[r][c], letter: input };\r\n    if (c + 1 \u003e 4) {\r\n      c = 4;\r\n    } else {\r\n      c += 1;\r\n    }\r\n    setWordMatrix(() =\u003e [...currArr]);\r\n    setCurrentRowCol({ c, r });\r\n  }\r\n});\r\n```\r\n\r\nEssentially what is being handled here is, when the user enters a letter, it gets validated and placed into a the current cell. the cell is then incremented to the right. When the user presses backspace, the letter is deleted from the cell and cell moves one to the left. Else, if the user presses `return` key, it moves over to the next row and what letters are correct/incorrent are validated. When the user has run out of all tries and has not won the game, the game's state will be set to `{won:false,completed:true}`.\r\n\r\nBasically that is what the game's logic is. You can check out the full source code in this [repo](https://github.com/portableCoder/Wordly).//]: \u003c\u003e (raw url: https://raw.githubusercontent.com/portableCoder/portableThoughts/main/blog/thought1.md)\r\n\r\nReact is one of the most popular front end frameworks out there. It supports a plethora of different platforms, but what you might not have known is that you\r\ncan even build a CLI application with react.\r\n\r\nThere are thousands of different wordle clones you can find online these days, mostly web-based. I wanted to recreate it too, but I had a different approach -- I wanted to make it a cli-based game. I also wanted to use react to make it, so I opted on using the great [React-Ink](https://github.com/vadimdemedes/ink) library which allows you to build react-based\r\nCLI-applications by utilizing a custom renderer for the command line.\r\n\r\nI started by initializing a 6x5 in a state like so:\r\n\r\n```ts\r\nconst [wordMatrix, setWordMatrix] = useState(() =\u003e {\r\n  let arr: Array\u003c\r\n    Array\u003c{\r\n      bgColor: LiteralUnion\u003ctypeof ForegroundColor, string\u003e;\r\n      letter: string;\r\n    }\u003e\r\n  \u003e = [];\r\n  for (let index = 0; index \u003c 6; index++) {\r\n    let arr_temp: Array\u003c{\r\n      bgColor: LiteralUnion\u003ctypeof ForegroundColor, string\u003e;\r\n      letter: string;\r\n    }\u003e = [];\r\n    for (let j = 0; j \u003c 5; j++) {\r\n      arr_temp.push({ bgColor: null, letter: \"\" });\r\n    }\r\n    arr.push(arr_temp);\r\n  }\r\n  return arr;\r\n});\r\n```\r\n\r\nYou may have noticed that each cell in my word matrix has a letter and a background color associated with. That is how i keep track of if a word is correct, or is correct\r\nis but at a wrong place or is incorrent.\r\n\r\nI then create another state with that keeps track of in which cell the user is entering characters at, like\r\n\r\n```ts\r\nconst [currentRowCol, setCurrentRowCol] = useState({ r: 0, c: 0 });\r\n```\r\n\r\nNext, I map the view with this matrix:\r\n\r\n```tsx\r\n\u003cBox\u003e\r\n  {wordMatrix.map((el, i) =\u003e {\r\n    const { r, c } = currentRowCol;\r\n    return (\r\n      \u003cBox\r\n        key={i}\r\n        flexDirection=\"row\"\r\n        alignItems=\"center\"\r\n        justifyContent=\"center\"\r\n      \u003e\r\n        {el.map((t, j) =\u003e (\r\n          \u003cBox\r\n            key={j}\r\n            width={6}\r\n            height={2}\r\n            borderColor={r === i \u0026\u0026 c == j ? \"redBright\" : \"cyan\"}\r\n            b\r\n            orderStyle=\"single\"\r\n          \u003e\r\n            \u003cText\r\n              bold\r\n              color=\"whiteBright\"\r\n              backgroundColor={wordMatrix[i][j].bgColor}\r\n              key={j}\r\n            \u003e\r\n              {\" \" + wordMatrix[i][j].letter + \" \"}\r\n            \u003c/Text\u003e\r\n          \u003c/Box\u003e\r\n        ))}\r\n      \u003c/Box\u003e\r\n    );\r\n  })}\r\n\u003c/Box\u003e\r\n```\r\n\r\nI have defined some logic to determine what background color to give to the text.\r\n\r\nnext, I defined the keyboard like so\r\n\r\n```tsx\r\nconst keyboard = [\r\n  [\"Q\", \"W\", \"E\", \"R\", \"T\", \"Y\", \"U\", \"I\", \"O\", \"P\"],\r\n  [\"A\", \"S\", \"D\", \"F\", \"G\", \"H\", \"J\", \"K\", \"L\"],\r\n  [\"Z\", \"X\", \"C\", \"V\", \"B\", \"N\", \"M\"],\r\n] as const;\r\n\r\n{\r\n  keyboard.map((el, i) =\u003e {\r\n    return (\r\n      \u003cBox\r\n        key={i}\r\n        flexDirection=\"row\"\r\n        alignItems=\"center\"\r\n        justifyContent=\"center\"\r\n      \u003e\r\n        {el.map((t, j) =\u003e {\r\n          // incorrectLetters is a state array that contains the incorrect letters\r\n          const color = incorrectLetters.find((ltr) =\u003e t === ltr)\r\n            ? \"gray\"\r\n            : \"white\";\r\n          return (\r\n            \u003cBox key={j} width={6} alignItems=\"center\" height={2}\u003e\r\n              \u003cText\r\n                backgroundColor={color}\r\n                color={color === \"white\" ? \"blackBright\" : \"whiteBright\"}\r\n                bold\r\n              \u003e\r\n                {\"  \" + t + \"  \"}\r\n              \u003c/Text\u003e\r\n            \u003c/Box\u003e\r\n          );\r\n        })}\r\n      \u003c/Box\u003e\r\n    );\r\n  });\r\n}\r\n```\r\n\r\nto generate a random word, I used the `randomWords` package like so:\r\n\r\n```ts\r\nconst getRWord = () =\u003e {\r\n  return randomWords({\r\n    exactly: 1,\r\n    maxLength: 5,\r\n  })[0].toUpperCase();\r\n};\r\n\r\nconst [word] = useState(() =\u003e {\r\n  let rword = getRWord();\r\n  while (rword.length !== 5) {\r\n    rword = getRWord();\r\n  }\r\n  return rword;\r\n});\r\n```\r\n\r\nNow, all that's required to do is to handle the input. For input, `react-ink` provides the `useInput` hook that takes a callback that fires when the user enters something to the command line.\r\n\r\n```ts\r\nuseInput((input, key) =\u003e {\r\n  input = input.toUpperCase();\r\n  if (key.return) {\r\n    let { c, r } = currentRowCol;\r\n    let wMatrix = [...wordMatrix];\r\n    let wordArr = word.split(\"\");\r\n    let arr = wMatrix[r];\r\n    let potentialArr = [];\r\n    arr.forEach((l, i) =\u003e {\r\n      let letter = l.letter;\r\n      let letterRandom = wordArr[i];\r\n      if (letter === letterRandom) {\r\n        l.bgColor = \"green\";\r\n        arr[i] = l;\r\n        potentialArr.forEach((el) =\u003e {\r\n          if (el.index !== i \u0026\u0026 el.descriptor.letter === l.letter) {\r\n            arr[el.index] = { ...el.descriptor, bgColor: \"gray\" };\r\n            setIncorrectLetters((prev) =\u003e [...prev, el.descriptor.letter]);\r\n          }\r\n        });\r\n      } else if (wordArr.find((rnd) =\u003e rnd === letter)) {\r\n        l.bgColor = \"yellow\";\r\n\r\n        arr[i] = l;\r\n        potentialArr.push({ descriptor: l, index: i });\r\n      } else {\r\n        setIncorrectLetters((prev) =\u003e [...prev, letter]);\r\n        l.bgColor = \"gray\";\r\n        arr[i] = l;\r\n      }\r\n    });\r\n\r\n    wMatrix[r] = [...arr];\r\n    setWordMatrix([...wMatrix]);\r\n    let correctAnswers = arr.filter((ar) =\u003e ar.bgColor === \"green\").length;\r\n    if (correctAnswers === 5) {\r\n      setGame((prev) =\u003e {\r\n        return { ...prev, completed: true, won: true };\r\n      });\r\n      exit();\r\n    }\r\n\r\n    r += 1;\r\n    c = 0;\r\n\r\n    if (r \u003e 5) {\r\n      let correctAnswers = wordMatrix[5].filter(\r\n        (ar) =\u003e ar.bgColor === \"green\"\r\n      ).length;\r\n      if (correctAnswers \u003c 5) {\r\n        setGame((prev) =\u003e {\r\n          return { ...prev, completed: true, won: false };\r\n        });\r\n      } else if (correctAnswers === 5) {\r\n        setGame((prev) =\u003e {\r\n          return { ...prev, completed: true, won: true };\r\n        });\r\n      }\r\n      exit();\r\n    }\r\n    setCurrentRowCol({ c, r });\r\n  } else if (key.backspace) {\r\n    let currArr = [...wordMatrix];\r\n\r\n    let { c, r } = currentRowCol;\r\n    currArr[r][c] = { ...currArr[r][c], letter: \"\" };\r\n    if (c !== 0) c -= 1;\r\n\r\n    setWordMatrix(() =\u003e [...currArr]);\r\n    setCurrentRowCol({ c, r });\r\n  } else if (input === keyboard.flat().find((el) =\u003e el === input)) {\r\n    let currArr = [...wordMatrix];\r\n\r\n    let { c, r } = currentRowCol;\r\n\r\n    currArr[r][c] = { ...currArr[r][c], letter: input };\r\n    if (c + 1 \u003e 4) {\r\n      c = 4;\r\n    } else {\r\n      c += 1;\r\n    }\r\n    setWordMatrix(() =\u003e [...currArr]);\r\n    setCurrentRowCol({ c, r });\r\n  }\r\n});\r\n```\r\n\r\nEssentially what is being handled here is, when the user enters a letter, it gets validated and placed into a the current cell. the cell is then incremented to the right. When the user presses backspace, the letter is deleted from the cell and cell moves one to the left. Else, if the user presses `return` key, it moves over to the next row and what letters are correct/incorrent are validated. When the user has run out of all tries and has not won the game, the game's state will be set to `{won:false,completed:true}`.\r\n\r\nBasically that is what the game's logic is. You can check out the full source code in this [repo](https://github.com/portableCoder/Wordly).\r\n","slug":"How-I-Made-Wordly"}]},"__N_SSG":true},"page":"/","query":{},"buildId":"DXlSUnRK6ILsiNxXinhG8","assetPrefix":"/portableThoughts","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>